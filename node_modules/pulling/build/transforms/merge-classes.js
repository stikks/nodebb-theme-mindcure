"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
exports.mergeClasses = () => (context) => {
    // first go through and store the parent classes
    const topDown = new Map();
    const nameToDeclaration = new Map();
    return (sourceFile) => {
        const findInheritance = (node) => {
            if (ts.isClassDeclaration(node) && node.name) {
                const name = node.name.text;
                nameToDeclaration.set(name, node);
                node.heritageClauses && node.heritageClauses
                    .forEach(clause => clause.types.forEach((type) => {
                    if (ts.isIdentifier(type.expression)) {
                        const parent = type.expression.text;
                        const top = topDown.get(parent) || new Set();
                        topDown.set(parent, top);
                        top.add(name);
                    }
                }));
            }
            return ts.visitEachChild(node, findInheritance, context);
        };
        ts.visitNode(sourceFile, findInheritance);
        // find fully mergable paths
        //   an inheritance path is fully mergeable if the parent class has only one child class
        //   if so, we'll merge them together and return the child class
        const paths = new Map();
        const recurse = (path) => {
            const set = topDown.get(path[path.length - 1]);
            if (set && set.size === 1) {
                const child = set.values().next().value;
                const existing = paths.get(child);
                if (existing) {
                    paths.delete(child);
                    return [...path, ...existing];
                }
                return recurse([...path, child]);
            }
            else {
                return path;
            }
        };
        topDown.forEach((set, key) => paths.set(key, recurse([key])));
        const tempPaths = new Map(paths);
        tempPaths.forEach(path => path.slice(1).forEach(key => tempPaths.delete(key)));
        const pathsFromBottom = new Map([...tempPaths].map(([, path]) => [
            path[path.length - 1],
            [...path].reverse(),
        ]).filter(([, path]) => path.length > 1));
        const visitor = (node) => {
            if (ts.isClassDeclaration(node) && node.name) {
                const name = node.name.text;
                if (topDown.has(name) && topDown.get(name).size < 2) {
                    return ts.createClassDeclaration(undefined, undefined, node.name, undefined, [], []);
                }
                const path = pathsFromBottom.get(name);
                path && path.map(name => nameToDeclaration.get(name))
                    .reduce((prev, dec) => {
                    if (!dec || !prev) {
                        return prev || dec;
                    }
                    const members = new Map(prev.members.map((elem) => [
                        elem.name.getText(sourceFile),
                        elem,
                    ]));
                    dec.members.forEach(elem => members.set(elem.name.getText(sourceFile), elem));
                    return ts.createClassDeclaration(dec.decorators, dec.modifiers, dec.name, dec.typeParameters, [], [...members.values()]);
                });
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        };
        return ts.visitNode(sourceFile, visitor);
    };
};
//# sourceMappingURL=merge-classes.js.map